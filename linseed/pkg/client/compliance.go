// Copyright (c) 2023 Tigera, Inc. All rights reserved.

package client

import (
	"context"

	"github.com/projectcalico/calico/libcalico-go/lib/json"
	v1 "github.com/projectcalico/calico/linseed/pkg/apis/v1"
	"github.com/projectcalico/calico/linseed/pkg/client/rest"
)

// ComplianceInterface has methods related to compliance.
type ComplianceInterface interface {
	Snapshots() SnapshotInterface
	ReportData() ReportDataInterface
	Benchmarks() BenchmarkInterface
}

type SnapshotInterface interface {
	Create(ctx context.Context, s []v1.Snapshot) (*v1.BulkResponse, error)
	List(ctx context.Context, p v1.Params) (*v1.List[v1.Snapshot], error)
}

type ReportDataInterface interface {
	Create(ctx context.Context, s []v1.ReportData) (*v1.BulkResponse, error)
	List(ctx context.Context, p v1.Params) (*v1.List[v1.ReportData], error)
}

type BenchmarkInterface interface {
	Create(ctx context.Context, s []v1.Benchmarks) (*v1.BulkResponse, error)
	List(ctx context.Context, p v1.Params) (*v1.List[v1.Benchmarks], error)
}

func newCompliance(c Client, cluster string) ComplianceInterface {
	return &compliance{restClient: c.RESTClient(), clusterID: cluster}
}

// compliance implements ComplianceInterface.
type compliance struct {
	restClient rest.RESTClient
	clusterID  string
}

func (f *compliance) Snapshots() SnapshotInterface {
	return &snapshots{c: *f}
}

func (f *compliance) ReportData() ReportDataInterface {
	return &reportData{c: *f}
}

func (f *compliance) Benchmarks() BenchmarkInterface {
	return &benchmarks{c: *f}
}

// snapshots implements SnapshotInterface
type snapshots struct {
	c compliance
}

// List gets the l3 flow list for the given flow input params.
func (f *snapshots) Create(ctx context.Context, s []v1.Snapshot) (*v1.BulkResponse, error) {
	body := []byte{}
	for _, e := range s {
		if len(body) != 0 {
			// Include a separator between logs.
			body = append(body, []byte("\n")...)
		}

		// Add each item.
		out, err := json.Marshal(e)
		if err != nil {
			return nil, err
		}
		body = append(body, out...)
	}

	res := v1.BulkResponse{}
	err := f.c.restClient.Post().
		Path("/compliance/snapshots/bulk").
		BodyJSON(body).
		ContentType(rest.ContentTypeMultilineJSON).
		Cluster(f.c.clusterID).
		Do(ctx).Into(&res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (f *snapshots) List(ctx context.Context, p v1.Params) (*v1.List[v1.Snapshot], error) {
	res := v1.List[v1.Snapshot]{}
	err := f.c.restClient.Post().
		Path("/compliance/snapshots").
		Params(p).
		Cluster(f.c.clusterID).
		Do(ctx).
		Into(&res)
	if err != nil {
		return nil, err
	}
	return &res, nil
}

// reportData implements ReportDataInterface
type reportData struct {
	c compliance
}

func (f *reportData) Create(ctx context.Context, s []v1.ReportData) (*v1.BulkResponse, error) {
	body := []byte{}
	for _, e := range s {
		if len(body) != 0 {
			// Include a separator between logs.
			body = append(body, []byte("\n")...)
		}

		// Make sure the UID field is set.
		// TODO: This is required because metav1.Time doesn't serialize properly,
		// and is used to build the UID... this means the UID generated by the
		// server won't match the one generated client-side. We need to fix the
		// serialization problem.
		e.ID = e.UID()

		// Add each item.
		out, err := json.Marshal(e)
		if err != nil {
			return nil, err
		}
		body = append(body, out...)
	}

	res := v1.BulkResponse{}
	err := f.c.restClient.Post().
		Path("/compliance/reports/bulk").
		BodyJSON(body).
		ContentType(rest.ContentTypeMultilineJSON).
		Cluster(f.c.clusterID).
		Do(ctx).Into(&res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (f *reportData) List(ctx context.Context, p v1.Params) (*v1.List[v1.ReportData], error) {
	res := v1.List[v1.ReportData]{}
	err := f.c.restClient.Post().
		Path("/compliance/reports").
		Params(p).
		Cluster(f.c.clusterID).
		Do(ctx).
		Into(&res)
	if err != nil {
		return nil, err
	}
	return &res, nil
}

// benchmarks implements BenchmarkInterface
type benchmarks struct {
	c compliance
}

func (f *benchmarks) Create(ctx context.Context, s []v1.Benchmarks) (*v1.BulkResponse, error) {
	body := []byte{}
	for _, e := range s {
		if len(body) != 0 {
			// Include a separator between logs.
			body = append(body, []byte("\n")...)
		}

		// Make sure the UID field is set.
		// TODO: This is required because metav1.Time doesn't serialize properly,
		// and is used to build the UID... this means the UID generated by the
		// server won't match the one generated client-side. We need to fix the
		// serialization problem.
		e.ID = e.UID()

		// Add each item.
		out, err := json.Marshal(e)
		if err != nil {
			return nil, err
		}
		body = append(body, out...)
	}

	res := v1.BulkResponse{}
	err := f.c.restClient.Post().
		Path("/compliance/benchmarks/bulk").
		BodyJSON(body).
		ContentType(rest.ContentTypeMultilineJSON).
		Cluster(f.c.clusterID).
		Do(ctx).Into(&res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (f *benchmarks) List(ctx context.Context, p v1.Params) (*v1.List[v1.Benchmarks], error) {
	res := v1.List[v1.Benchmarks]{}
	err := f.c.restClient.Post().
		Path("/compliance/benchmarks").
		Params(p).
		Cluster(f.c.clusterID).
		Do(ctx).
		Into(&res)
	if err != nil {
		return nil, err
	}
	return &res, nil
}
