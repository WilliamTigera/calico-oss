// Copyright (c) 2021 Tigera, Inc. All rights reserved.

package capture

import (
	"context"
	"fmt"

	log "github.com/sirupsen/logrus"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	cerrors "github.com/projectcalico/calico/libcalico-go/lib/errors"
	"github.com/projectcalico/calico/packetcapture-api/pkg/cache"

	v3 "github.com/tigera/api/pkg/apis/projectcalico/v3"
)

const tigeraFluentdNs = "tigera-fluentd"

// K8sCommands determines how to access the files generated by a packet capture
type K8sCommands interface {
	// GetEntryPod return the namespace and name of the entry pod or an error otherwise
	GetEntryPod(clusterID, node string) (string, string, error)
	// GetPacketCapture returns the packet capture or an error otherwise
	GetPacketCapture(clusterID, name, namespace string) (*v3.PacketCapture, error)
	// UpdatePacketCaptureStatusWithNoFiles updates the status for a packet capture that
	// corresponds with the node given
	UpdatePacketCaptureStatusWithNoFiles(clusterID, name, namespace string, nodes map[string]struct{}) error
}

type k8sCommands struct {
	cache cache.ClientCache
}

func (k8sCmd *k8sCommands) GetPacketCapture(clusterID, name, namespace string) (*v3.PacketCapture, error) {
	var cs, _, err = k8sCmd.cache.GetClientAndConfig(clusterID)
	if err != nil {
		return nil, err
	}

	packetCapture, err := cs.ProjectcalicoV3().PacketCaptures(namespace).Get(context.Background(), name, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return packetCapture, nil
}

// NewK8sCommands uses the fluentd pods in order to execute a remote copy command for the files
// generated by a packet capture
func NewK8sCommands(cache cache.ClientCache) K8sCommands {
	return &k8sCommands{cache: cache}
}

func (k8sCmd *k8sCommands) GetEntryPod(clusterID, node string) (string, string, error) {
	var cs, _, err = k8sCmd.cache.GetClientAndConfig(clusterID)
	if err != nil {
		return "", "", err
	}

	pods, err := cs.CoreV1().Pods(tigeraFluentdNs).List(context.Background(), metav1.ListOptions{
		FieldSelector: fmt.Sprintf("spec.nodeName=%s,status.phase=Running", node),
	})
	if err != nil {
		return "", "", err
	}
	if len(pods.Items) != 1 {
		return "", "", fmt.Errorf("failed to locate a valid entry point")
	}

	return pods.Items[0].Namespace, pods.Items[0].Name, nil
}

func (k8sCmd *k8sCommands) UpdatePacketCaptureStatusWithNoFiles(clusterID, name, namespace string, nodes map[string]struct{}) error {
	var cs, _, err = k8sCmd.cache.GetClientAndConfig(clusterID)
	if err != nil {
		return err
	}

	packetCapture, err := cs.ProjectcalicoV3().PacketCaptures(namespace).Get(context.Background(), name, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for i, file := range packetCapture.Status.Files {
		if _, ok := nodes[file.Node]; ok {
			packetCapture.Status.Files[i].FileNames = []string{}
		}
	}

	_, err = cs.ProjectcalicoV3().PacketCaptures(namespace).UpdateStatus(context.Background(), packetCapture, metav1.UpdateOptions{})
	if err != nil {
		switch err.(type) {
		case cerrors.ErrorResourceDoesNotExist:
			log.WithError(err).Warnf("Resource was delete and does not require an update")
		default:
			return err
		}
	}
	return err
}
