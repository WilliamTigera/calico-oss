// Copyright (c) 2022 Tigera Inc. All rights reserved.

package namespace

import (
	"context"
	"errors"

	v1 "k8s.io/api/core/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"

	"github.com/projectcalico/calico/continuous-policy-recommendation/pkg/cache"
	"github.com/projectcalico/calico/continuous-policy-recommendation/pkg/syncer"
	"github.com/projectcalico/calico/libcalico-go/lib/backend/api"
	"github.com/projectcalico/calico/libcalico-go/lib/backend/model"
	"github.com/projectcalico/calico/ts-queryserver/pkg/querycache/client"

	log "github.com/sirupsen/logrus"
)

type namespaceReconciler struct {
	kubernetes    kubernetes.Interface
	resourceCache cache.ObjectCache[*v1.Namespace]
	synchronizer  client.QueryInterface
}

func NewNamespaceReconciler(
	kubernetes kubernetes.Interface,
	resourceCache cache.ObjectCache[*v1.Namespace],
	synchronizer client.QueryInterface,
) *namespaceReconciler {
	return &namespaceReconciler{
		kubernetes:    kubernetes,
		resourceCache: resourceCache,
		synchronizer:  synchronizer,
	}
}

// Reconcile Listens to events for Namespaces on the cluster and triggers the synchronization of the
// caches hosting the resources generated by the PolicyRecommendationEngine which currently are
// StagedNetworkPolicy and NetworkSet caches.
func (nr *namespaceReconciler) Reconcile(name types.NamespacedName) error {
	if nr.kubernetes == nil {
		err := errors.New("calico client is nil, unable to access datastore")
		log.WithError(err)

		return err
	}

	ctx := context.Background()

	namespace, err := nr.kubernetes.CoreV1().Namespaces().Get(
		ctx, name.Name, metav1.GetOptions{})
	if err != nil && !k8serrors.IsNotFound(err) {
		return err
	}

	if k8serrors.IsNotFound(err) { // deleted namespace
		// namespace is deleted, delete all policies associated with the namespace
		log.Infof("Namespace %s deleted, removing all associated policies with the namespace", name)

		nr.resourceCache.Delete(name.Name)
		_, err = nr.synchronizer.RunQuery(ctx, syncer.NamespaceQuery{
			MetaSelectors: syncer.MetaSelectors{
				Source: &api.Update{
					UpdateType: api.UpdateTypeKVDeleted,
					KVPair: model.KVPair{
						Key: model.ResourceKey{
							Name: name.Name,
							Kind: KindNamespace,
						},
					},
				},
			},
		})

		if err != nil {
			log.Error(err)
			return err
		}
		return nil
	}

	// handle create or update
	nr.resourceCache.Set(namespace.Name, namespace)
	_, err = nr.synchronizer.RunQuery(ctx, syncer.NamespaceQuery{
		MetaSelectors: syncer.MetaSelectors{
			Source: &api.Update{
				UpdateType: api.UpdateTypeKVNew,
				KVPair: model.KVPair{
					Key: model.ResourceKey{
						Name: namespace.Name,
						Kind: namespace.Kind,
					},
					Value: namespace,
				},
			},
			Labels: namespace.Labels,
		},
	})

	if err != nil {
		log.Error(err)
		return err
	}
	return nil
}

func (nr *namespaceReconciler) Close() {
}
