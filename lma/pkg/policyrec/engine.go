// Copyright (c) 2019, 2022 Tigera, Inc. All rights reserved.
package policyrec

import (
	"fmt"
	"reflect"
	"sort"
	"strings"

	log "github.com/sirupsen/logrus"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	v3 "github.com/tigera/api/pkg/apis/projectcalico/v3"
	"github.com/tigera/api/pkg/lib/numorstring"

	"github.com/projectcalico/calico/libcalico-go/lib/set"
	"github.com/projectcalico/calico/lma/pkg/api"
	lmak8s "github.com/projectcalico/calico/lma/pkg/k8s"
)

// Labels to ignore. These labels are known ones that are generated by controllers or can change.
var labelKeysToIgnore = set.FromArray([]string{
	"pod-template-hash",
	"job-name",
	"controller-uid",
	"pod-template-generation",
	"controller-revision-hash",
	"statefulset.kubernetes.io/pod-name",
	"app.kubernetes.io/instance",
})

const (
	noNamespace    = ""
	noEndpointName = ""

	policyRecommendationNameSuffix = "policy"

	// TODO(doublek): Import these from libcalico-go when we bump pins.
	namespaceByNameLabel    = "projectcalico.org/name"
	globalNamespaceSelector = "global()"
)

// The rules for recommend policy are aggregated per endpoint + protocol with
// a list of ports and computed selector.

// endpointRulePerProtocol is the key that represents this.
type endpointRulePerProtocol struct {
	endpointName      string
	endpointNamespace string
	protocol          numorstring.Protocol
}

// entityRule is the value that holds the list of ports and computed selectors.
type entityRule struct {
	namespaceSelector string
	ports             set.Set[numorstring.Port]
	selector          selectorBuilder
	// TODO(doublek): Add service account string
}

// endpointBySelector groups selectors with protocols to dedup any duplicated rules
// that share the same selectors for a particular protocol.
type endpointBySelector struct {
	endpointSelector  string
	namespaceSelector string
	protocol          numorstring.Protocol
}

// recommendationEngine implements the RecommendationEngine interface.
// Policies are recommended for a given endpoint in a namespace.
type recommendationEngine struct {
	// K8s client set interface.
	clientSet lmak8s.ClientSet
	// endpointName is the name of endpoint for which the policy recommendation
	// was requested for.
	endpointName string
	// endpointNamespace is the namespace of the endpoint for which the
	// policy recommendation was requested for.
	endpointNamespace string

	// namespace of the recommended policy.
	policyNamespace string
	// The tier of the policy - obtained from observation point.
	policyTier string
	// The order of the policy - obtained from observation point.
	policyOrder *float64
	// selector of the recommended policy.
	// We currently only support AND-ed selectors. All the key:value
	// pairs of the map are AND-ed in the final selector string.
	policySelector selectorBuilder
	// ingress rules of the recommended policy.
	// TODO(doublek): This doesn't need to be here. It can probably be constructed
	// and used on the fly.
	ingressRules []v3.Rule
	// egress rules of the recommended policy.
	// TODO(doublek): This doesn't need to be here. It can probably be constructed
	// and used on the fly.
	egressRules []v3.Rule
	// ingressTraffic tracks the ingress traffic to this endpoint
	ingressTraffic map[endpointRulePerProtocol]entityRule
	// egressTraffic tracks the egress traffic to this endpoint
	egressTraffic map[endpointRulePerProtocol]entityRule
	// isNamespacePolicy true if the policy is in reference to a namespace, with rules referencing
	// namespaces.
	isNamespacePolicy bool
}

func NewEndpointRecommendationEngine(
	cs lmak8s.ClientSet, name, namespace, policyTier string, policyOrder *float64,
) *recommendationEngine {
	return &recommendationEngine{
		clientSet:         cs,
		endpointName:      name,
		endpointNamespace: namespace,
		policyNamespace:   namespace,
		policyTier:        policyTier,
		policyOrder:       policyOrder,
		ingressRules:      []v3.Rule{},
		egressRules:       []v3.Rule{},
		ingressTraffic:    map[endpointRulePerProtocol]entityRule{},
		egressTraffic:     map[endpointRulePerProtocol]entityRule{},
		isNamespacePolicy: IsEmptyEndpointName(name) && !IsEmptyNamespace(namespace),
	}
}

// ProcessFlow takes a flow log and updates the recommendation engine policies.
func (ere *recommendationEngine) ProcessFlow(flow api.Flow) error {
	// We only support allowed flows.
	if flow.ActionFlag&api.ActionFlagAllow == 0 {
		return fmt.Errorf("%v isn't an allowed flow", flow)
	}

	// Make sure we only process flows that have either source or destination namespace for namespace
	// based policies, or name/namespace for endpoint based policies.
	if !ere.matchesSource(flow) && !ere.matchesDestination(flow) {
		return fmt.Errorf("namespace/name of flow %v don't match request or endpoint isn't a Workload Endpoint",
			flow)
	}

	if ere.isNamespacePolicy {
		protocol := *flow.Proto
		port := flow.Destination.Port
		if flow.Reporter == api.ReporterTypeSource && ere.matchesSource(flow) {
			namespace := flow.Destination.Namespace
			ere.processNamespaceRuleFromFlow(ere.egressTraffic, namespace, port, protocol)
		} else if flow.Reporter == api.ReporterTypeDestination && ere.matchesDestination(flow) {
			namespace := flow.Source.Namespace
			ere.processNamespaceRuleFromFlow(ere.ingressTraffic, namespace, port, protocol)
		}
	} else {
		// Update selector from flow.
		ere.updateSelectorFromFlow(flow)

		// Next up is constructing rules.
		ere.processRuleFromFlow(flow)
	}

	return nil
}

// Recommend returns a recommendation containing network policies based on the processing flow logs.
func (ere *recommendationEngine) Recommend() (*Recommendation, error) {
	recommendation := &Recommendation{
		NetworkPolicies:       []*v3.StagedNetworkPolicy{},
		GlobalNetworkPolicies: []*v3.StagedGlobalNetworkPolicy{},
	}
	// Set the policy's name.
	var name string
	if ere.isNamespacePolicy {
		if err, ok := DoesNamespaceExist(ere.clientSet, ere.endpointNamespace); err != nil {
			log.WithError(err).Errorf("failed to query for namespace: %s", ere.endpointNamespace)
			return nil, err
		} else if !ok {
			log.WithError(err).Errorf("failed to query for namespace: %s", ere.endpointNamespace)
			return nil, fmt.Errorf("namespace '%s' not found", name)
		}
		name = ere.endpointNamespace
	} else {
		name = GeneratePolicyName(ere.clientSet, ere.endpointName, ere.endpointNamespace)
	}

	ere.constructRulesFromTraffic()

	if len(ere.ingressRules) == 0 && len(ere.egressRules) == 0 {
		err := fmt.Errorf("no matching flows to compute rules for namespace/name %v/%v",
			ere.endpointNamespace, ere.endpointName)
		log.WithError(err).Info("Could not calculate rules")
		return nil, err
	}

	policyTypes := []v3.PolicyType{}
	if len(ere.ingressRules) > 0 {
		policyTypes = append(policyTypes, v3.PolicyTypeIngress)
	}
	if len(ere.egressRules) > 0 {
		policyTypes = append(policyTypes, v3.PolicyTypeEgress)
	}
	if IsEmptyEndpointName(ere.endpointName) {
		snp := v3.NewStagedNetworkPolicy()
		snp.ObjectMeta = metav1.ObjectMeta{
			Name:      fmt.Sprintf("%s.%s-%s", ere.policyTier, name, policyRecommendationNameSuffix),
			Namespace: ere.policyNamespace,
		}
		policySelector := fmt.Sprintf("%s == '%s'", namespaceByNameLabel, ere.policyNamespace)

		snp.Spec = v3.StagedNetworkPolicySpec{
			StagedAction: v3.StagedActionSet,
			Tier:         ere.policyTier,
			Types:        policyTypes,
			Selector:     policySelector,
			Ingress:      ere.ingressRules,
			Egress:       ere.egressRules,
		}
		recommendation.NetworkPolicies = append(recommendation.NetworkPolicies, snp)
	} else if IsEmptyNamespace(ere.policyNamespace) {
		// If the engine is for an endpoint with no namespace, then we
		// recommend a globalnetworkpolicy.
		gnp := v3.NewStagedGlobalNetworkPolicy()
		gnp.ObjectMeta = metav1.ObjectMeta{
			Name: fmt.Sprintf("%s.%s", ere.policyTier, name),
		}
		policySelector := ere.policySelector.Expression()
		if policySelector == "" {
			err := fmt.Errorf("could not compute selector for namespace/name: %v/%v",
				ere.endpointNamespace, ere.endpointName)
			log.WithError(err).Info("Could not compute selector")
			return nil, err
		}
		gnp.Spec = v3.StagedGlobalNetworkPolicySpec{
			StagedAction: v3.StagedActionSet,
			Tier:         ere.policyTier,
			Types:        policyTypes,
			Selector:     policySelector,
			Ingress:      ere.ingressRules,
			Egress:       ere.egressRules,
		}
		recommendation.GlobalNetworkPolicies = append(recommendation.GlobalNetworkPolicies, gnp)
	} else {
		np := v3.NewStagedNetworkPolicy()
		np.ObjectMeta = metav1.ObjectMeta{
			Name:      fmt.Sprintf("%s.%s", ere.policyTier, name),
			Namespace: ere.policyNamespace,
		}
		policySelector := ere.policySelector.Expression()
		if policySelector == "" {
			err := fmt.Errorf("could not compute selector for namespace/name: %v/%v",
				ere.endpointNamespace, ere.endpointName)
			log.WithError(err).Info("Could not compute selector")
			return nil, err
		}
		np.Spec = v3.StagedNetworkPolicySpec{
			StagedAction: v3.StagedActionSet,
			Tier:         ere.policyTier,
			Types:        policyTypes,
			Selector:     policySelector,
			Ingress:      ere.ingressRules,
			Egress:       ere.egressRules,
		}
		recommendation.NetworkPolicies = append(recommendation.NetworkPolicies, np)
	}
	return recommendation, nil
}

func IsEmptyEndpointName(name string) bool {
	return name == noEndpointName
}

func IsEmptyNamespace(namespace string) bool {
	return namespace == noNamespace
}

// updateSelectorFromFlow extracts labels from relevant flows and updates the
// main policy selector.
func (ere *recommendationEngine) updateSelectorFromFlow(flow api.Flow) {
	var labels map[string]string
	if ere.matchesSource(flow) {
		labels = flow.Source.Labels
	}
	if ere.matchesDestination(flow) {
		labels = flow.Destination.Labels
	}
	if ere.policySelector != nil {
		ere.policySelector.IntersectLabels(labels)
	} else {
		ere.policySelector = NewSelectorBuilder(labels)
	}
}

// processNamespaceRuleFromFlow collects traffic information for constructing namespace based
// policy rules.
func (ere *recommendationEngine) processNamespaceRuleFromFlow(
	entityRules map[endpointRulePerProtocol]entityRule,
	namespace string,
	port *uint16,
	proto uint8,
) {
	// A flow reported at the source will add an egress rule to an destination port + protocol.
	key := endpointRulePerProtocol{
		endpointNamespace: namespace,
		protocol:          api.GetProtocol(proto),
	}
	erule, ok := entityRules[key]
	if !ok {
		erule = entityRule{
			namespaceSelector: namespace,
			ports:             set.New[numorstring.Port](),
		}
	}
	if port != nil {
		erule.ports.Add(numorstring.SinglePort(*port))
	}

	log.Debugf("Adding egress traffic %+v with labels %+v", key, erule)
	entityRules[key] = erule
}

// processRuleFromFlow collects traffic information for constructing policy rules.
func (ere *recommendationEngine) processRuleFromFlow(flow api.Flow) {
	// Process a flow and append to appropriate rule. Rules are processed
	// in the following order:
	//   1. Service account rules go first. TODO(doublek).
	//   2. Named ports matches go next. TODO(doublek).
	//   3. Finally, port + protocol matches.
	// The current assumption is that a single flow will yield a single rule.
	if flow.Reporter == api.ReporterTypeSource && ere.matchesSource(flow) {
		// A flow reported at the source will add an egress rule to an destination port + protocol.
		erpp := endpointRulePerProtocol{
			endpointName:      flow.Destination.Name,
			endpointNamespace: flow.Destination.Namespace,
			protocol:          api.GetProtocol(*flow.Proto),
		}
		rule, ok := ere.egressTraffic[erpp]
		if ok {
			rule.selector.IntersectLabels(flow.Destination.Labels)
		} else {
			rule = entityRule{
				selector: NewSelectorBuilder(flow.Destination.Labels),
				ports:    set.New[numorstring.Port](),
			}
		}
		if flow.Destination.Port != nil {
			rule.ports.Add(numorstring.SinglePort(*flow.Destination.Port))
		}
		ere.egressTraffic[erpp] = rule
		log.Debugf("Adding egress traffic %+v with labels %+v", erpp, rule)
	} else if flow.Reporter == api.ReporterTypeDestination && ere.matchesDestination(flow) {
		// A flow reported at the destination will add an ingress rule to the destination
		// port + protocol.
		erpp := endpointRulePerProtocol{
			endpointName:      flow.Source.Name,
			endpointNamespace: flow.Source.Namespace,
			protocol:          api.GetProtocol(*flow.Proto),
		}

		rule, ok := ere.ingressTraffic[erpp]
		if ok {
			rule.selector.IntersectLabels(flow.Source.Labels)
		} else {
			rule = entityRule{
				selector: NewSelectorBuilder(flow.Source.Labels),
				ports:    set.New[numorstring.Port](),
			}
		}
		if flow.Destination.Port != nil {
			rule.ports.Add(numorstring.SinglePort(*flow.Destination.Port))
		}
		ere.ingressTraffic[erpp] = rule
		log.Debugf("Adding ingress traffic %+v with labels %+v", erpp, rule)
	}
}

// constructRulesFromTraffic creates ingress and egress rules for use in a policy.
func (ere *recommendationEngine) constructRulesFromTraffic() {
	if ere.isNamespacePolicy {
		// Remove the ingress reference of any duplicate rules, and report only as egress.
		for key, eval := range ere.egressTraffic {
			if ival, ok := ere.ingressTraffic[key]; ok {
				if reflect.DeepEqual(eval, ival) {
					delete(ere.ingressTraffic, key)
				}
			}
		}
	}

	if len(ere.egressTraffic) != 0 {
		ere.egressRules = ere.rulesFromTraffic(v3.PolicyTypeEgress, ere.egressTraffic)
	}
	if len(ere.ingressTraffic) != 0 {
		ere.ingressRules = ere.rulesFromTraffic(v3.PolicyTypeIngress, ere.ingressTraffic)
	}
}

// namespaceRulesFromTraffic is a convenience method for converting intermediate traffic
// representation to libcalico-go v3 Rule object, for namespace based rules.
func (ere *recommendationEngine) rulesFromTraffic(
	policyType v3.PolicyType, trafficAndSelector map[endpointRulePerProtocol]entityRule,
) []v3.Rule {
	log.WithField("policyType", policyType).Debugf("Processing rules for traffic %+v",
		trafficAndSelector)

	rules := []v3.Rule{}
	dedupedRules := map[endpointBySelector]entityRule{}
	for erpp, erule := range trafficAndSelector {
		var endpointSelector, namespaceSelector string
		if ere.isNamespacePolicy {
			namespaceSelector = selectNamespaceByName(erpp.endpointNamespace)
		} else {
			endpointSelector = erule.selector.Expression()
			if IsEmptyEndpointName(erpp.endpointNamespace) {
				// Only include the global() selector if we want to actually select a Calico
				// HostEndpoint. For all other non namespaced non-Calico endpoints, we just leave
				// out all selectors.
				if !erule.selector.IsEmpty() {
					namespaceSelector = globalNamespaceSelector
				}
			} else if erpp.endpointNamespace != ere.endpointNamespace {
				namespaceSelector = selectNamespaceByName(erpp.endpointNamespace)
			}
		}

		key := endpointBySelector{
			endpointSelector:  endpointSelector,
			namespaceSelector: namespaceSelector,
			protocol:          erpp.protocol,
		}

		// Try to also collect all ports together for same selectors.
		if dedupedRule, ok := dedupedRules[key]; ok {
			dedupedRule.ports.Iter(func(item numorstring.Port) error {
				erule.ports.Add(item)
				return nil
			})
		}
		dedupedRules[key] = erule
	}

	log.WithField("policyType", policyType).Debugf("Deduped rules for traffic %+v", dedupedRules)

	for key, dprule := range dedupedRules {
		ports := []numorstring.Port{}
		dprule.ports.Iter(func(item numorstring.Port) error {
			ports = append(ports, item)
			return nil
		})
		protocol := key.protocol

		rule := newRule(key.endpointSelector, key.namespaceSelector, policyType, ports, protocol)
		rules = append(rules, *rule)
	}

	sortRules(policyType, &rules)

	log.WithField("policyType", policyType).Debugf("Rules for traffic %+v", rules)

	return rules
}

// matchesSource checks if the flow matches the source.
func (ere *recommendationEngine) matchesSource(flow api.Flow) bool {
	if ere.isNamespacePolicy {
		return flow.Source.Namespace == ere.endpointNamespace &&
			flow.Source.Type == api.FlowLogEndpointTypeWEP &&
			flow.Reporter == api.ReporterTypeSource
	}

	return flow.Source.Name == ere.endpointName &&
		flow.Source.Namespace == ere.endpointNamespace &&
		flow.Source.Type == api.FlowLogEndpointTypeWEP &&
		flow.Reporter == api.ReporterTypeSource
}

// matchesDestination checks if the flow matches the destination.
func (ere *recommendationEngine) matchesDestination(flow api.Flow) bool {
	if ere.isNamespacePolicy {
		return flow.Destination.Namespace == ere.endpointNamespace &&
			flow.Destination.Type == api.FlowLogEndpointTypeWEP &&
			flow.Reporter == api.ReporterTypeDestination
	}

	return flow.Destination.Name == ere.endpointName &&
		flow.Destination.Namespace == ere.endpointNamespace &&
		flow.Destination.Type == api.FlowLogEndpointTypeWEP &&
		flow.Reporter == api.ReporterTypeDestination
}

// newRule returns a pointer to a v3 rule that is defined by the action, ports, protocol, namespace
// and endpoint selector.
func newRule(
	endpointSelector string,
	namespaceSelector string,
	policyType v3.PolicyType,
	ports []numorstring.Port,
	proto numorstring.Protocol,
) *v3.Rule {

	rule := &v3.Rule{
		Action:   v3.Allow,
		Protocol: &proto,
		Destination: v3.EntityRule{
			Ports: ports,
		},
	}

	// The entityRule is translated to an ingress or egress policy depending on the
	// policyType specified. Rule selectors are constructed based on the following.
	// Rule selectors only select endpoints within the main policy selectors namespace.
	// To workaround this issue, we do the following:
	// 1. For namespaced endpoints not belonging to the current policy's endpoint, we
	//    include the "all()" as the namespaceSelector to select all namespaced endpoints
	//    and then specify the current policy's namespace using the hidden
	//    "projectcalico.org/namespace == '<namespace>'" selector.
	// 2. For global/non-namespaced endpoints, we specify a "!all()" selector which
	//    will select all non namespaced endpoints.
	// TODO(doublek): Fix this when we have nicer namespaced selectors.
	if policyType == v3.PolicyTypeEgress {
		rule.Destination.Selector = endpointSelector
		rule.Destination.NamespaceSelector = namespaceSelector
	} else {
		rule.Source.Selector = endpointSelector
		rule.Source.NamespaceSelector = namespaceSelector
	}

	return rule
}

// sortRules sort rules by namespace, and protocol name.
func sortRules(policyType v3.PolicyType, rules *[]v3.Rule) {
	sort.Slice(*rules, func(i, j int) bool {
		if policyType == v3.PolicyTypeEgress {
			if (*rules)[i].Destination.NamespaceSelector != (*rules)[j].Destination.NamespaceSelector {
				return (*rules)[i].Destination.NamespaceSelector < (*rules)[j].Destination.NamespaceSelector
			}
		} else {
			if (*rules)[i].Source.NamespaceSelector != (*rules)[j].Source.NamespaceSelector {
				return (*rules)[i].Source.NamespaceSelector < (*rules)[j].Source.NamespaceSelector
			}
		}
		return strings.ToLower((*rules)[i].Protocol.String()) <
			strings.ToLower((*rules)[j].Protocol.String())
	})
}

// selectorBuilder wraps a map to provide convenience methods selector construction.
type selectorBuilder map[string]string

// Creates and initializes a selectorBuilder with the provided labels.
func NewSelectorBuilder(labels map[string]string) selectorBuilder {
	sb := make(selectorBuilder)
	for k, v := range labels {
		sb[k] = v
	}
	return sb
}

// IntersectLabels creates the intersection of current labels with additional
// labels provided.
func (sb selectorBuilder) IntersectLabels(labels map[string]string) {
	// If there are no labels present, intersection should be empty as well.
	if len(sb) == 0 {
		return
	}
	for k, v := range labels {
		value, ok := sb[k]
		if ok && value != v {
			delete(sb, k)
		}
	}
	for k := range sb {
		_, ok := labels[k]
		if !ok {
			delete(sb, k)
		}
	}
}

// Expression constructs a selector expression for the labels stored in the
// selectorBuilder. Currently only "&&"-ed selector expressions are supported.
func (sb selectorBuilder) Expression() string {
	if len(sb) == 0 {
		return ""
	}
	expressionParts := []string{}
	for k, v := range sb {
		if labelKeysToIgnore.Contains(k) {
			continue
		}
		expressionParts = append(expressionParts, fmt.Sprintf("%s == '%s'", k, v))
	}
	return strings.Join(expressionParts, " && ")
}

// IsEmpty returns if there are no labels present in the label map.
func (sb selectorBuilder) IsEmpty() bool {
	return len(sb) == 0
}

// selectNamespaceByName constructs a selector of the form
// "projectcalico.org/name == 'passed-in-namespace'". This is suitable for use
// in a namespaceSelector to select a namespace by name.
func selectNamespaceByName(namespace string) string {
	if IsEmptyNamespace(namespace) {
		return globalNamespaceSelector
	}
	return fmt.Sprintf("%s == '%s'", namespaceByNameLabel, namespace)
}
