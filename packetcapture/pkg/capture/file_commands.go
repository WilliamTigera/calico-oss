// Copyright (c) 2021 Tigera, Inc. All rights reserved.

package capture

import (
	"bytes"
	"fmt"
	"io"

	v1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/tools/remotecommand"

	"github.com/projectcalico/calico/packetcapture/pkg/cache"
)

// FileCommands provides methods to access/delete the files generated by a packet capture
type FileCommands interface {
	// OpenTarReader opens a tar reader for all the files that can be found at entryPoint on a cluster identified
	// by clusterID.
	OpenTarReader(clusterID string, entryPoint EntryPoint) (tarReader io.Reader, errorReader io.Reader, err error)
	Delete(clusterID string, entryPoint EntryPoint) (errorReader io.Reader, err error)
}

type fileCommands struct {
	cache cache.ClientCache
}

// NewFileCommands executes a remote command via the fluentd pods to retrieve/delete the files
// generated by a packet capture
func NewFileCommands(clientCache cache.ClientCache) FileCommands {
	return &fileCommands{cache: clientCache}
}

func (f *fileCommands) OpenTarReader(clusterID string, entryPoint EntryPoint) (io.Reader, io.Reader, error) {
	var dir = fmt.Sprintf("%s/%s/%s", entryPoint.CaptureDirectory, entryPoint.CaptureNamespace, entryPoint.CaptureName)
	return f.command(clusterID, entryPoint, []string{"tar", "cf", "-", dir})
}

func (f *fileCommands) Delete(clusterID string, entryPoint EntryPoint) (errorReader io.Reader, err error) {
	var dir = fmt.Sprintf("%s/%s/%s", entryPoint.CaptureDirectory, entryPoint.CaptureNamespace, entryPoint.CaptureName)
	_, errorReader, err = f.command(clusterID, entryPoint, []string{"rm", "-rf", dir})
	return errorReader, err
}

func (f *fileCommands) command(clusterID string, entryPoint EntryPoint, command []string) (io.Reader, io.Reader, error) {
	var cs, config, err = f.cache.GetClientAndConfig(clusterID)
	if err != nil {
		return nil, nil, err
	}
	req := cs.CoreV1().RESTClient().Post().
		Resource("pods").
		Name(entryPoint.PodName).
		Namespace(entryPoint.PodNamespace).
		SubResource("exec")

	req.VersionedParams(
		&v1.PodExecOptions{
			Command: command,
			Stdin:   false,
			Stdout:  true,
			Stderr:  true,
			TTY:     false,
		},
		scheme.ParameterCodec,
	)
	var stderr bytes.Buffer
	var reader, writer = io.Pipe()
	exec, err := remotecommand.NewSPDYExecutor(config, "POST", req.URL())
	if err != nil {
		return nil, nil, err
	}

	go func() {
		defer writer.Close()
		err = exec.Stream(remotecommand.StreamOptions{
			Stdin:  nil,
			Stdout: writer,
			Stderr: &stderr,
		})
		if err != nil {
			stderr.Write([]byte(fmt.Sprintf("Remote command failed with error=%s", err.Error())))
		}
	}()

	return reader, &stderr, nil
}
