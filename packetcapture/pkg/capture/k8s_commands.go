// Copyright (c) 2021-2022 Tigera, Inc. All rights reserved.

package capture

import (
	"context"
	"fmt"

	log "github.com/sirupsen/logrus"
	v3 "github.com/tigera/api/pkg/apis/projectcalico/v3"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	cerrors "github.com/projectcalico/calico/libcalico-go/lib/errors"
	"github.com/projectcalico/calico/packetcapture/pkg/cache"
)

const (
	fluentdNamespace = "tigera-fluentd"
	// fluentd container name is hard-coded in operator fluentd render.
	// see: https://github.com/tigera/operator/blob/230ec8fa2697fb8e620f13e691f51a04981fe672/pkg/render/fluentd.go#L534
	fluentdContainerName = "fluentd"
)

// K8sCommands determines how to access the files generated by a packet capture
type K8sCommands interface {
	// GetEntryPod return the namespace and name of the entry pod or an error otherwise
	GetEntryPod(clusterID, node string) (*EntryPod, error)
	// GetPacketCapture returns the packet capture or an error otherwise
	GetPacketCapture(clusterID, name, namespace string) (*v3.PacketCapture, error)
	// UpdatePacketCaptureStatusWithNoFiles updates the status for a packet capture that
	// corresponds with the node given
	UpdatePacketCaptureStatusWithNoFiles(clusterID, name, namespace string, nodes map[string]struct{}) error
}

type k8sCommands struct {
	cache cache.ClientCache
}

func (k8sCmd *k8sCommands) GetPacketCapture(clusterID, name, namespace string) (*v3.PacketCapture, error) {
	var cs, _, err = k8sCmd.cache.GetClientAndConfig(clusterID)
	if err != nil {
		return nil, err
	}

	packetCapture, err := cs.ProjectcalicoV3().PacketCaptures(namespace).Get(context.Background(), name, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return packetCapture, nil
}

// NewK8sCommands uses the fluentd pods in order to execute a remote copy command for the files
// generated by a packet capture
func NewK8sCommands(cache cache.ClientCache) K8sCommands {
	return &k8sCommands{cache: cache}
}

func (k8sCmd *k8sCommands) GetEntryPod(clusterID, node string) (*EntryPod, error) {
	var cs, _, err = k8sCmd.cache.GetClientAndConfig(clusterID)
	if err != nil {
		return nil, err
	}

	pods, err := cs.CoreV1().Pods(fluentdNamespace).List(context.Background(), metav1.ListOptions{
		FieldSelector: fmt.Sprintf("spec.nodeName=%s,status.phase=Running", node),
	})
	if err != nil {
		return nil, err
	}
	if len(pods.Items) != 1 {
		return nil, fmt.Errorf("failed to locate a valid entry point")
	}

	return &EntryPod{
		// If other containers are side-loaded with the fluentd container, the remote exec command
		// fails with error to specify the container name for the fluentd pod.
		// Return the fluentd container name for packetcapture remote commands.
		// see: https://tigera.atlassian.net/browse/CI-998
		ContainerName: fluentdContainerName,
		PodName:       pods.Items[0].Name,
		PodNamespace:  pods.Items[0].Namespace,
	}, nil
}

func (k8sCmd *k8sCommands) UpdatePacketCaptureStatusWithNoFiles(clusterID, name, namespace string, nodes map[string]struct{}) error {
	var cs, _, err = k8sCmd.cache.GetClientAndConfig(clusterID)
	if err != nil {
		return err
	}

	packetCapture, err := cs.ProjectcalicoV3().PacketCaptures(namespace).Get(context.Background(), name, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for i, file := range packetCapture.Status.Files {
		if _, ok := nodes[file.Node]; ok {
			packetCapture.Status.Files[i].FileNames = []string{}
		}
	}

	_, err = cs.ProjectcalicoV3().PacketCaptures(namespace).UpdateStatus(context.Background(), packetCapture, metav1.UpdateOptions{})
	if err != nil {
		switch err.(type) {
		case cerrors.ErrorResourceDoesNotExist:
			log.WithError(err).Warnf("Resource was delete and does not require an update")
		default:
			return err
		}
	}
	return err
}
