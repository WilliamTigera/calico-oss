// Copyright (c) 2022-2023 Tigera Inc. All rights reserved.

package syncer

import (
	"context"
	"fmt"
	"reflect"
	"strings"

	log "github.com/sirupsen/logrus"

	v1 "k8s.io/api/core/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	v3 "github.com/tigera/api/pkg/apis/projectcalico/v3"

	"github.com/projectcalico/calico/libcalico-go/lib/backend/api"
	"github.com/projectcalico/calico/libcalico-go/lib/backend/model"
	libcalicoselector "github.com/projectcalico/calico/libcalico-go/lib/selector"
	lmak8s "github.com/projectcalico/calico/lma/pkg/k8s"
	calicores "github.com/projectcalico/calico/policy-recommendation/pkg/calico-resources"
	"github.com/projectcalico/calico/policy-recommendation/utils"
	"github.com/projectcalico/calico/ts-queryserver/pkg/querycache/client"
)

const (
	selectorNamespaceKey            = "projectcalico.org/name"
	ownerReferenceKindLabelSelector = "projectcalico.org/ownerReference.kind=PolicyRecommendationScope"
)

// NewCacheSynchronizer creates the QueryInterface instance
func NewCacheSynchronizer(clientSet lmak8s.ClientSet, cacheSet CacheSet, suffixGenerator func() string) client.QueryInterface {
	return &synchronizer{
		clientSet:       clientSet,
		cacheSet:        cacheSet,
		suffixGenerator: suffixGenerator,
	}
}

type synchronizer struct {
	policyRecScope  *v3.PolicyRecommendationScope
	clientSet       lmak8s.ClientSet
	cacheSet        CacheSet
	suffixGenerator func() string
}

// RunQuery is used to  synchronize the caches referenced in the CacheSet from Kubernetes events
// from the controllers watching the respective Kubernetes resource.
func (s *synchronizer) RunQuery(ctx context.Context, req any) (any, error) {
	switch resourceQuery := req.(type) {
	case PolicyRecommendationScopeQuery:
		return s.synchronizeFromPolicyRec(ctx, resourceQuery)
	case NamespaceQuery:
		return s.synchronizeFromNamespaces(ctx, resourceQuery)
	default:
		return nil, fmt.Errorf("unhandled query type: %#v", req)
	}
}

func (s *synchronizer) synchronizeFromPolicyRec(ctx context.Context, query PolicyRecommendationScopeQuery) (*PolicyReqScopeQueryResult, error) {
	switch query.Source.UpdateType {
	case api.UpdateTypeKVNew, api.UpdateTypeKVUpdated:
		policyRecScope, ok := query.Source.Value.(*v3.PolicyRecommendationScope)

		if !ok {
			return nil, fmt.Errorf(
				"received non PolicyRecommendationScope type in synchronization handler %s",
				reflect.TypeOf(query.Source.Value),
			)
		}

		s.policyRecScope = policyRecScope

		// Sync all Namespaces in the cache with the cluster
		nslist, err := s.clientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
		if err != nil {
			return nil, err
		}

		// Parse the selector expression
		selector := s.policyRecScope.Spec.NamespaceSpec.Selector
		parsedSelector, err := libcalicoselector.Parse(selector)
		if err != nil {
			log.WithError(err).Errorf("failed to parse selector: %s", selector)
			return nil, err
		}

		// Only deploy staged network policies for namespaces without excluded prefixes
		namespaces := []v1.Namespace{}
		for _, ns := range nslist.Items {
			// Filter out namespaces only if the selector successfully parses.
			if parsedSelector == nil {
				// Selector did not successfully parse, all namespaces will be recommended
				namespaces = append(namespaces, ns)
			} else if parsedSelector != nil && parsedSelector.Evaluate(map[string]string{selectorNamespaceKey: ns.Name}) {
				// This namespace should be recommended, as its evaluation against the selector returned true
				namespaces = append(namespaces, ns)
			}
		}

		var results []*v3.StagedNetworkPolicy
		errors := make(map[string]error, 0)
		for _, namespace := range namespaces {
			// sync the namespace cache to initialize it from the PolicyRecSpec deployment
			s.cacheSet.Namespaces.Set(namespace.GetName(), &namespace)
			result := s.addRecommendationToCache(ctx, namespace, policyRecScope.Spec.NamespaceSpec.TierName)
			if result != nil {
				results = append(results, result)
			}
		}

		if len(errors) > 0 {
			return nil, s.compactErrors("from creating StagedNetworkPolicies for the following Namespaces %s", errors)
		}

		return &PolicyReqScopeQueryResult{StagedNetworkPolicies: results}, nil
	case api.UpdateTypeKVDeleted:
		// Delete the StagedNetworkPolicies generated by the cluster
		stagedNetworkPolicies := s.cacheSet.StagedNetworkPolicies.GetAll()

		for _, snp := range stagedNetworkPolicies {
			err := s.deleteUntrackedSNP(ctx, *snp)

			if err != nil {
				log.WithError(err).Warnf("Error deleting StagedNetworkPolicy: %s , continuing", snp.Name)
			}
		}

		if err := calicores.DeleteTier(ctx, s.clientSet.ProjectcalicoV3(), s.policyRecScope.Spec.NamespaceSpec.TierName); err != nil {
			return nil, err
		}

		s.policyRecScope = nil
		log.Debugf("Recognized PolicyRecommendationScope Delete event that does not affect Namespace state")
		return nil, nil
	default:
		return nil, fmt.Errorf("unhandled Update type: %#v", query.Source.UpdateType)
	}
}

func (s *synchronizer) synchronizeFromNamespaces(ctx context.Context, query NamespaceQuery) (*NamespaceQueryResult, error) {
	if s.policyRecScope == nil || s.policyRecScope.Spec.NamespaceSpec.RecStatus != v3.PolicyRecommendationScopeEnabled {
		log.Debug("Ignore request for Namespace change when PolicyRecommendationScope is not enabled")
		return nil, nil
	}

	switch query.Source.UpdateType {
	case api.UpdateTypeKVNew, api.UpdateTypeKVUpdated:
		namespacesource, ok := query.Source.Value.(*v1.Namespace)
		if !ok {
			return nil, fmt.Errorf("received non Namespace type in synchronization handler %s", reflect.TypeOf(query.Source.Value))
		}

		// Verify that this namespace should be recommended

		// Parse the selector expression
		selector := s.policyRecScope.Spec.NamespaceSpec.Selector
		parsedSelector, err := libcalicoselector.Parse(selector)
		if err != nil {
			log.WithError(err).Errorf("failed to parse selector: %s", selector)
			return nil, err
		} else if parsedSelector != nil && !parsedSelector.Evaluate(map[string]string{selectorNamespaceKey: namespacesource.Name}) {
			// This namespace should not be recommended
			log.Debugf("Ignoring namespace: %s. Names with this prefix should not be recommended.", namespacesource.Name)
			return nil, nil
		}
		log.Infof("Namespace: %s, added to policy recommendation engine", namespacesource.Name)

		result := s.addRecommendationToCache(ctx, *namespacesource, s.policyRecScope.Spec.NamespaceSpec.TierName)

		return &NamespaceQueryResult{
			StagedNetworkPolicies: []*v3.StagedNetworkPolicy{result},
		}, nil

	case api.UpdateTypeKVDeleted:
		namespaceKey, ok := query.Source.Key.(model.ResourceKey)
		if !ok {
			return nil, fmt.Errorf("received unrecognizable Key format %s", reflect.TypeOf(query.Source.Key))
		}
		// Iterate through the generated StagedNetworkPolicies and remove all those in the deleted namespace
		errors := make(map[string]error, 0)
		var results []*v3.StagedNetworkPolicy
		for _, snp := range s.cacheSet.StagedNetworkPolicies.GetAll() {
			snpName := snp.Name
			if snp.Namespace == namespaceKey.Name {
				err := s.deleteUntrackedSNP(ctx, *snp)
				if err != nil {
					errors[snpName] = err
				} else {
					results = append(results, snp)
				}
				continue
			}

			snp.Spec.Ingress = removeNamespaceContainingRule(snp.Spec.Ingress, namespaceKey.Name)
			snp.Spec.Egress = removeNamespaceContainingRule(snp.Spec.Egress, namespaceKey.Name)

			var err error
			var updatedSnp *v3.StagedNetworkPolicy
			if len(snp.Spec.Ingress) == 0 && len(snp.Spec.Egress) == 0 {
				err = s.deleteUntrackedSNP(ctx, *snp)
			} else {
				updatedSnp, err = s.updateSNP(ctx, snp)
			}

			if err != nil {
				errors[snpName] = err
			} else {
				results = append(results, updatedSnp)
			}
		}

		if len(errors) > 0 {
			return nil, s.compactErrors("from deleting following StagedNetworkPolicies %s", errors)
		}

		return &NamespaceQueryResult{StagedNetworkPolicies: results}, nil
	default:
		return nil, fmt.Errorf("unhandled Update type: %#v", query.Source.UpdateType)
	}
}

func removeNamespaceContainingRule(rules []v3.Rule, namespace string) []v3.Rule {
	for i := len(rules) - 1; i >= 0; i-- {
		rule := rules[i]
		if strings.Contains(rule.Destination.NamespaceSelector, namespace) ||
			strings.Contains(rule.Source.NamespaceSelector, namespace) {
			rules = append(rules[:i], rules[i+1:]...)
		}
	}

	return rules
}

// addRecommendationToCache adds a recommendation for this namespace to the cache. Copies over an
// existing recommendation from the store, or creates a new recommendation, if a store item
// doesn't exist.
func (s *synchronizer) addRecommendationToCache(ctx context.Context, namespace v1.Namespace, tier string) *v3.StagedNetworkPolicy {
	// If a store value already exists, set that as the cache item
	log.Debugf("Get staged network policy list for namespace: %s", namespace.Name)

	labelSelector := strings.Join([]string{
		fmt.Sprintf("%s=%s", calicores.TierKey, tier), // projectcalico.org/tier=<TIER_NAME>
		ownerReferenceKindLabelSelector,
	}, ",")

	if storeSnps, err := s.clientSet.ProjectcalicoV3().StagedNetworkPolicies(namespace.Name).List(ctx, metav1.ListOptions{
		LabelSelector: labelSelector,
	}); err == nil {
		// We are working around the inability to GET the StagedNetworkPolicy from the
		// 'namespace-isolation' tier
		if len(storeSnps.Items) > 0 {
			// A store value already exists, add that to the cache and don't create a new one.

			snp := &v3.StagedNetworkPolicy{}

			// There should only exist one recommendation within this namespace
			utils.CopyStagedNetworkPolicy(snp, storeSnps.Items[0])

			log.WithField("key", snp).Debug("Adding recommendation to cache")
			s.cacheSet.StagedNetworkPolicies.Set(namespace.Name, snp)

			return snp
		}

	}

	if s.cacheSet.StagedNetworkPolicies.Get(namespace.Name) == nil {
		// No store or cache item exists, create a new one
		name := namespace.GetName()
		ns := namespace.GetName()
		owner := getRecommendationScopeOwner(s.policyRecScope)

		log.WithField("key", name).Debugf("Creating new recommendation")
		snp := calicores.NewStagedNetworkPolicy(utils.GetPolicyName(tier, name, s.suffixGenerator), ns, tier, *owner)

		s.cacheSet.StagedNetworkPolicies.Set(namespace.Name, snp)

		return snp
	}

	return nil
}

func (s *synchronizer) updateSNP(ctx context.Context, snp *v3.StagedNetworkPolicy) (*v3.StagedNetworkPolicy, error) {
	namespace := snp.GetNamespace()
	key := namespace
	result, err := s.clientSet.ProjectcalicoV3().StagedNetworkPolicies(namespace).Update(
		ctx,
		snp,
		metav1.UpdateOptions{},
	)

	if err != nil {
		return nil, err
	}

	s.cacheSet.StagedNetworkPolicies.Set(key, result)

	return result, nil
}

func (s *synchronizer) deleteUntrackedSNP(ctx context.Context, snp v3.StagedNetworkPolicy) error {
	namespace := snp.GetNamespace()
	key := namespace
	err := s.clientSet.ProjectcalicoV3().StagedNetworkPolicies(namespace).Delete(
		ctx,
		snp.GetName(),
		metav1.DeleteOptions{},
	)

	if err != nil && !k8serrors.IsNotFound(err) {
		return err
	}

	s.cacheSet.StagedNetworkPolicies.Delete(key)
	return nil
}

func (s *synchronizer) compactErrors(format string, errors map[string]error) error {
	var errStrs []string
	for resourceName, err := range errors {
		errStrs = append(errStrs, fmt.Sprintf("%s: %s", resourceName, err.Error()))
	}
	return fmt.Errorf(format, strings.Join(errStrs, ", "))
}

// getRecommendationScopeOwner returns policy recommendation scope resource as an owner reference
// resource.
func getRecommendationScopeOwner(scope *v3.PolicyRecommendationScope) *metav1.OwnerReference {
	ctrl := true
	blockOwnerDelete := false

	log.Debugf("Owner - apiversion: %s, kind: %s, name: %s, uid: %s", scope.APIVersion, scope.Kind, scope.Name, scope.UID)

	return &metav1.OwnerReference{
		APIVersion:         "projectcalico.org/v3",
		Kind:               "PolicyRecommendationScope",
		Name:               scope.Name,
		UID:                scope.UID,
		Controller:         &ctrl,
		BlockOwnerDeletion: &blockOwnerDelete,
	}
}
