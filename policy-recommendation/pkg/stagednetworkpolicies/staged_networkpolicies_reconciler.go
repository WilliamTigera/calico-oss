// Copyright (c) 2023 Tigera Inc. All rights reserved.

package stagednetworkpolicies

import (
	"context"
	"fmt"
	"reflect"

	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	v3 "github.com/tigera/api/pkg/apis/projectcalico/v3"
	calicoclient "github.com/tigera/api/pkg/client/clientset_generated/clientset/typed/projectcalico/v3"

	"github.com/projectcalico/calico/policy-recommendation/pkg/cache"
	calicoresources "github.com/projectcalico/calico/policy-recommendation/pkg/calico-resources"

	log "github.com/sirupsen/logrus"
)

type stagednetworkpoliciesReconciler struct {
	calico        calicoclient.ProjectcalicoV3Interface
	resourceCache cache.ObjectCache[*v3.StagedNetworkPolicy]
}

// Reconcile Listens to Kubernetes events (update, delete) for the StagedNetworkPolicies generated
// by the PolicyRecommendationEngine (filtered by the PRE label).  If any StagedNetworkPolicies
// generated by the PRE is manually altered, restore the generated version of the SNP held in the
// cache to the cluster.
func (sr *stagednetworkpoliciesReconciler) Reconcile(namespacedName types.NamespacedName) error {
	name := fmt.Sprintf("namespace-segmentation.%s-recommendation", namespacedName.Name)
	snp, err := sr.calico.StagedNetworkPolicies(namespacedName.Namespace).Get(
		context.Background(),
		name,
		metav1.GetOptions{},
	)
	if err != nil && !k8serrors.IsNotFound(err) {
		return err
	}

	cachedSNP := sr.resourceCache.Get(name)
	if cachedSNP == nil || reflect.ValueOf(cachedSNP).IsNil() {
		log.Debugf("Ignoring untracked StagedNetworkPolicy %s from Policy Recommendation", name)
		return nil
	}

	// Handle Restoring deleted StagedNetworkPolicy managed by policy recommendation
	if k8serrors.IsNotFound(err) {
		// Create an empty staged network policy. We want to relearn
		newCacheSnp := calicoresources.NewStagedNetworkPolicy(cachedSNP.Name, cachedSNP.Namespace, cachedSNP.Spec.Tier, cachedSNP.OwnerReferences[0])
		sr.resourceCache.Set(name, newCacheSnp)
	}

	if snp.Spec.StagedAction != cachedSNP.Spec.StagedAction {
		if snp.Spec.StagedAction == v3.StagedActionIgnore || snp.Spec.StagedAction == v3.StagedActionSet {
			cachedSNP.Spec.StagedAction = snp.Spec.StagedAction
		}
	}

	return nil
}

func (sr *stagednetworkpoliciesReconciler) Close() {
	snps := sr.resourceCache.GetAll()
	for _, snp := range snps {
		err := sr.calico.StagedNetworkPolicies(snp.Namespace).Delete(
			context.Background(),
			snp.Name,
			metav1.DeleteOptions{},
		)

		if err != nil {
			log.WithError(err).Warnf("Error deleting StagedNetworkPolicy: %s continuing as to not block close()", snp.Name)
		}
	}
}
